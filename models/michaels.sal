michaels {N_ : nznat} : CONTEXT = BEGIN

LABEL : TYPE = DATATYPE
  test
END;

STRING : TYPE = {String_hello};

STATES : TYPE = {State_0, State_1, State_2, NULL_STATE};
%%10
value : CONTEXT = value {N_, STRING};
arithmetic : CONTEXT = arithmetic{N_, STRING};

TRILEAN : TYPE = arithmetic ! TRILEAN;
B_VALUE : TYPE =  value ! B_VALUE;
VALUE : TYPE =  value ! VALUE;
value_option : CONTEXT = option {VALUE};                         %%20

VALUE_OPTION : TYPE =  value_option ! OPTION;

Some : [VALUE -> VALUE_OPTION] = value_option ! Some;
NUM : [value ! int -> VALUE] = value ! NUM;
STR : [STRING -> VALUE] = value ! STR;

value_plus : [[VALUE_OPTION, VALUE_OPTION] -> VALUE_OPTION] =
arithmetic ! value_plus;
value_minus : [[VALUE_OPTION, VALUE_OPTION] -> VALUE_OPTION] =   %%30
arithmetic ! value_minus;

value_le : [[VALUE_OPTION, VALUE_OPTION] -> TRILEAN] =
arithmetic ! value_le;
value_ge : [[VALUE_OPTION, VALUE_OPTION] -> TRILEAN] =
arithmetic ! value_ge;
value_lt : [[VALUE_OPTION, VALUE_OPTION] -> TRILEAN] =
arithmetic ! value_lt;
value_gt : [[VALUE_OPTION, VALUE_OPTION] -> TRILEAN] =
arithmetic ! value_gt;                                         %%40
value_eq : [[VALUE_OPTION, VALUE_OPTION] -> TRILEAN] =
arithmetic ! value_eq;

output_sequence : CONTEXT = sequence {value_option !
B_OPTION, value_option ! OPTION_BB, 1};
input_sequence : CONTEXT = sequence {B_VALUE, value !
VALUE_BB, 1};
gval : [TRILEAN -> BOOLEAN] = LAMBDA(g : TRILEAN) : g =
arithmetic ! True;
                        %%50
check_underflow : [VALUE_OPTION -> BOOLEAN] =
LAMBDA(v : VALUE_OPTION) : gval(value_ge(v, Some(NUM(0-N_))));
check_overflow : [VALUE_OPTION -> BOOLEAN] =
LAMBDA(v : VALUE_OPTION) : gval(value_le(v, Some(NUM(N_))));

MichaelsEFSM : MODULE =
  BEGIN
    INPUT label : LABEL
    LOCAL cfstate : STATES
    LOCAL r_1 : VALUE_OPTION
    LOCAL r_2 : VALUE_OPTION
    LOCAL r_3 : VALUE_OPTION
    INPUT I : input_sequence ! Sequence
    OUTPUT O : output_sequence ! Sequence                         %%60
    INITIALIZATION [
        cfstate = State_0 AND
        O = output_sequence ! empty AND
        r_1 = value_option ! None AND
        r_2 = value_option ! None AND
        r_3 = value_option ! None
      -->
    ]
    TRANSITION [
      %% test                                                    %%70
      ALL_SYNTAX :
          cfstate = State_1 AND label = test AND
              input_sequence ! size?(I) = 4 AND
              gval(value_eq(value_plus(r_1, Some(I(1))), Some(NUM(7)))) AND
              gval(value_gt(Some(NUM(3)), value_minus(Some(I(4)), r_3)))
              AND gval(value_ge(r_2, Some(NUM(0)))) AND
              gval(value_ge(r_2, Some(NUM(0)))) AND
              gval(value_eq(r_3, value_option ! None)) AND
              gval(value_le(value_plus(Some(NUM(5)), r_2),
              Some(NUM(N_))))                                      %%80
        -->
          cfstate' = State_2;
          r_1' = value_plus(Some(NUM(5)), r_2);
          r_2' = Some(STR(String_hello));
          O' = output_sequence !
              insert(Some(NUM(5)), output_sequence !
              insert(Some(STR(String_hello)), output_sequence !
              insert(r_2, output_sequence !
              insert(Some(I(2)), output_sequence !
              insert(value_plus(Some(NUM(5)), r_2), output_sequence %%90
              ! insert(value_minus(value_plus(Some(NUM(5)), r_2),
              Some(NUM(5))), output_sequence ! empty))))));
          r_3' = r_3
      []
      SINK_HOLE :
          ELSE
        -->
          cfstate' = NULL_STATE;
          r_1' = r_1;
          r_2' = r_2;                                            %%100
          r_3' = r_3
    ]
  END;
END
