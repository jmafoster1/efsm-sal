horrible_example_1 {N_ : nznat} : CONTEXT = BEGIN

LABEL : TYPE = DATATYPE
  f,
  g,
  h
END;

STATES : TYPE = {State_0, State_1, State_2, NULL_STATE};
                                                                 %%10
NAT : TYPE = [0..N_];
STRING : TYPE = {dummy};

Value:CONTEXT = value {N_, STRING};
Arithmetic:CONTEXT = arithmetic{N_, STRING};

B_VALUE : TYPE =  Value ! B_VALUE;
VALUE : TYPE =  {g : B_VALUE | g /= value {N_, STRING} ! VALUE_BB};
ValueOption:CONTEXT = option {VALUE};


B_VALUE_OPTION : TYPE = ValueOption ! B_OPTION;
VALUE_OPTION : TYPE =  {g : B_VALUE_OPTION | g /= ValueOption ! OPTION_BB};
BOOL_OPTION : TYPE = option {bool} ! OPTION;

Some : [VALUE -> VALUE_OPTION] = ValueOption ! Some;
NUM: [Value!NAT -> VALUE] = Value ! NUM;
STR: [STRING -> VALUE] = Value ! STR;

value_plus : [[VALUE_OPTION, VALUE_OPTION] -> VALUE_OPTION] = Arithmetic ! value_plus;
value_minus : [[VALUE_OPTION, VALUE_OPTION] -> VALUE_OPTION] = Arithmetic ! value_minus;

value_le : [[VALUE_OPTION, VALUE_OPTION] -> BOOL_OPTION] = Arithmetic ! value_le;
value_ge : [[VALUE_OPTION, VALUE_OPTION] -> BOOL_OPTION] = Arithmetic ! value_ge;
value_lt : [[VALUE_OPTION, VALUE_OPTION] -> BOOL_OPTION] = Arithmetic ! value_lt;
value_gt : [[VALUE_OPTION, VALUE_OPTION] -> BOOL_OPTION] = Arithmetic ! value_gt;

OutputSequence : CONTEXT = sequence {B_VALUE_OPTION; ValueOption ! OPTION_BB, 0};
InputSequence : CONTEXT = sequence {B_VALUE; value {N_, STRING} ! VALUE_BB, 1};

gval : [BOOL_OPTION -> bool] =
LAMBDA(g:BOOL_OPTION): g = option {bool} !Some(TRUE);

vend : MODULE =
  BEGIN
    INPUT label : LABEL                                          %%20
    LOCAL cfstate : STATES
    LOCAL r_1 : VALUE_OPTION
    INPUT I : InputSequence ! Sequence
    INITIALIZATION [
        cfstate = State_0 AND
        r_1 = ValueOption ! None
      -->
    ]
    TRANSITION [
      %% f                                                       %%30
      T1 :
          cfstate = State_0 AND
          label = f
        -->
          cfstate' = State_1;
          r_1' = Some(I(1))
      []
      %% g
      T2 :
          cfstate = State_1 AND
          label = g AND
          gval(value_gt(r_1, Some(NUM(5)))) AND
          gval(value_le(value_plus(r_1, Some(NUM(5))), Some(NUM(N_))))
        -->
          cfstate' = State_1;
          r_1' = value_plus(r_1, Some(NUM(5)));
      []
      %% h
      T3 :
          cfstate = State_1 AND
          label = h AND
          gval(value_lt(r_1, Some(NUM(10))))
        -->
          cfstate' = State_2;
          r_1' = r_1                                             %%50
      []
      %% h
      T4 :
          cfstate = State_1 AND
          label = h AND
          gval(value_ge(r_1, Some(NUM(10))))
        -->
          cfstate' = State_2;
          r_1' = r_1
      []
      SINK_HOLE :
          ELSE                                                   %%60
        -->
          cfstate' = NULL_STATE;
          r_1' = r_1
    ]
  END;
  path: THEOREM vend |- FORALL (x:NAT): (label=f AND I(1) = NUM(x) AND
                        X(label=h AND I =InputSequence! empty) =>
                        X(X(cfstate=State_2)));

END
