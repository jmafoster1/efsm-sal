coin_choc_broken {n_ : nznat} : CONTEXT = BEGIN

LABEL : TYPE = DATATYPE
  coin,
  init,
  vend
END;

STRING : TYPE = {String_dummy_};
STATE : TYPE = {State_0, State_1, State_2, NULL_STATE};

IMPORTING trilean;
IMPORTING value{n_, STRING};
IMPORTING option{VALUE};
IMPORTING arithmetic{n_, STRING};

output_sequence : CONTEXT = sequence {B_OPTION, OptionBB, 1};
input_sequence : CONTEXT = sequence {B_VALUE, ValueBB, 1};

drinks : MODULE =
  BEGIN
    INPUT label : LABEL
    LOCAL cfstate : STATE
    LOCAL r_1 : OPTION
    INPUT I : input_sequence ! Sequence                          %%60
    OUTPUT O : output_sequence ! Sequence
    INITIALIZATION [
        cfstate = State_0 AND
        I = input_sequence ! empty AND
        O = output_sequence ! empty AND
        r_1 = None
      -->
    ]
    TRANSITION [
      %% init                                                    %%70
      INIT :
          cfstate = State_0 AND label = init AND
              input_sequence ! size?(I) = 0
        -->
          cfstate' = State_1;
          r_1' = Some(Num(0));
          O' = output_sequence ! empty
      []
      %% coin
      COIN :                                                     %%80
          cfstate = State_1 AND label = coin AND
              input_sequence ! size?(I) = 0 AND
              check_overflow(value_plus(r_1, Some(Num(1)))) AND
              check_underflow(value_plus(r_1, Some(Num(1))))
        -->
          cfstate' = State_1;
          r_1' = value_plus(r_1, Some(Num(1)));
          O' = output_sequence ! empty
      []
      %% vend                                                    %%90
      VEND :
          cfstate = State_1 AND label = vend AND
              input_sequence ! size?(I) = 0 AND
              gval(value_ge(r_1, Some(Num(0)))) AND
              check_overflow(value_minus(r_1, Some(Num(1)))) AND
              check_underflow(value_minus(r_1, Some(Num(1))))
        -->
          cfstate' = State_2;
          r_1' = value_minus(r_1, Some(Num(1)));
          O' = output_sequence ! empty                           %%100
      []
      SINK_HOLE :
          ELSE
        -->
          cfstate' = NULL_STATE;
          r_1' = r_1
    ]
  END;
  LTL_label_vend_not_2 : THEOREM drinks |-
    label = vend => NOT (F(cfstate = State_2));                  %%110

  LTL_aux2 : THEOREM drinks |-
    X(label = vend) => NOT (F(cfstate = State_2));

  LTL_init_makes_r_1_zero : THEOREM drinks |-
    label = init AND
        I = input_sequence ! empty =>
        X(gval(value_eq(r_1,(Some(Num(0))))));

  LTL_must_pay_wrong : THEOREM drinks |-                         %%120
    U(NOT (U(label = vend, label = coin)), cfstate = NULL_STATE);

  LTL_vend_no_coin : THEOREM drinks |-
    X(label = vend AND
        I = input_sequence ! empty) => NOT (F(cfstate = State_2));

  LTL_invalid_gets_stuck_2 : THEOREM drinks |-
    X(NOT (label = coin AND I = input_sequence ! empty)) AND
    X(NOT (label = vend AND I = input_sequence ! empty)) =>
    NOT (F(cfstate = State_2));%%130

  LTL_must_pay_correct : THEOREM drinks |-
    F(cfstate = State_2) => U(NOT (label = vend), label = coin);

END
