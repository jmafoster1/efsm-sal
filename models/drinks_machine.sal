drinks_machine{N_ : nznat} : CONTEXT = BEGIN

LABEL : TYPE = DATATYPE
  coin,
  select,
  vend
END;

STRING : TYPE = {String_coke, String_invalid};
                                                                 %%10
STATES : TYPE = {State_0, State_1, State_2, NULL_STATE};

B_dm_value : TYPE =  value {N_, STRING} ! B_VALUE;
dm_value : TYPE =  {g : B_dm_value | g /= value {N_, STRING} ! VALUE_BB};
B_dm_value_option : TYPE = option {dm_value} ! B_OPTION;
dm_value_option : TYPE =  {g : B_dm_value_option | g /= option {dm_value} ! OPTION_BB};

bool_option : TYPE = option {bool} ! OPTION;

Some : [dm_value -> dm_value_option] = option {dm_value} ! Some;
NUM: [value{N_, STRING}!NAT -> dm_value] = value {N_, STRING} ! NUM;
STR: [STRING -> dm_value] = value {N_, STRING} ! STR;

value_plus : [[dm_value_option, dm_value_option] -> dm_value_option] = arithmetic{N_, STRING} ! value_plus;
value_le : [[dm_value_option, dm_value_option] -> bool_option] = arithmetic{N_, STRING} ! value_le;
value_ge : [[dm_value_option, dm_value_option] -> bool_option] = arithmetic{N_, STRING} ! value_ge;
value_lt : [[dm_value_option, dm_value_option] -> bool_option] = arithmetic{N_, STRING} ! value_lt;

gval : [bool_option -> bool] =
LAMBDA(g:bool_option): g = option {bool} !Some(TRUE);

drinks : MODULE =
  BEGIN
    INPUT label : LABEL
    LOCAL cfstate : STATES
    LOCAL r_1 : option {dm_value} ! OPTION
    LOCAL r_2 : option {dm_value} ! OPTION                                         %%30
    INPUT I : sequence {B_dm_value; value {N_, STRING} ! VALUE_BB, 1} ! Sequence
    OUTPUT O : sequence {B_dm_value_option; option {dm_value} ! OPTION_BB, 1} ! Sequence
    INITIALIZATION [
        cfstate = State_0 AND
        r_1 = option {dm_value} ! None AND
        r_2 = option {dm_value} ! None
      -->
    ]                                                            %%40
    TRANSITION [
      %% select
      SELECT :
          cfstate = State_0 AND label = select
          AND sequence {B_dm_value; value {N_, STRING} ! VALUE_BB, 1} ! size?(I) = 1
        -->
          cfstate' = State_1;
          r_1' = option {dm_value} ! Some(I(1));
          r_2' = option {dm_value} ! Some(NUM(0));
      []
      %% coin                                                    %%50
      COIN :
          cfstate = State_1 AND label = coin
          AND gval(value_le(value_plus(r_2, Some(I(1))), Some(NUM(N_))))
          AND sequence {B_dm_value; value {N_, STRING} ! VALUE_BB, 1} ! size?(I) = 1
        -->
          cfstate' = State_1;
          r_1' = r_1;
          r_2' = value_plus(r_2, Some(I(1)));
          O' = sequence {B_dm_value_option; option {dm_value} ! OPTION_BB, 1} !singleton(value_plus(r_2, Some(I(1))))
      []
      %% vend                                                    %%60
      VEND :
          cfstate = State_1 AND label = vend
          AND gval(value_ge(r_2, Some(NUM(100))))
          AND sequence {B_dm_value; value {N_, STRING} ! VALUE_BB, 1} ! size?(I) = 0
        -->
          cfstate' = State_2;
          r_1' = r_1;
          r_2' = r_2;
          O' = sequence {B_dm_value_option; option {dm_value} ! OPTION_BB, 1} !singleton(r_1)
      []
      %% vend                                                    %%70
      VEND_FAIL :
          cfstate = State_1 AND label = vend
          AND gval(value_lt(r_2, Some(NUM(100))))
          AND sequence {B_dm_value; value {N_, STRING} ! VALUE_BB, 1} ! size?(I) = 0
        -->
          cfstate' = State_1;
          r_1' = r_1;
          r_2' = r_2
      []
      SINK_HOLE :
          ELSE                                                   %%80
        -->
          cfstate' = NULL_STATE;
          r_1' = r_1;
          r_2' = r_2
    ]
  END;
  costsMoney: THEOREM drinks |- G(X(cfstate=State_2) => gval(value_ge(r_2, Some(NUM(100)))));
  neverReachS2: THEOREM drinks |- label=select AND I(1) = STR(String_coke) AND
                                  X(label=coin AND I(1) = NUM(100)) AND
                                  X(X(label=vend AND I=sequence {B_dm_value; value {N_, STRING} ! VALUE_BB, 1} ! empty)) => X(X(X(cfstate=State_2)));
  %null_String: THEOREM drinks |- STR(null_value) = String_coke;

END
