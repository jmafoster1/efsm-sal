coin_choc {N_ : nznat} : CONTEXT = BEGIN

LABEL : TYPE = DATATYPE
  coin,
  init,
  vend
END;

STRING : TYPE = {String_dummy_};
                                                                 %%10
STATES : TYPE = {State_0, State_1, State_2, NULL_STATE};

Value:CONTEXT = value {N_, STRING};
Arithmetic:CONTEXT = arithmetic{N_, STRING};

B_VALUE : TYPE =  Value ! B_VALUE;
VALUE : TYPE =  {g : B_VALUE | g /= value {N_, STRING} !
    VALUE_BB};
ValueOption:CONTEXT = option {VALUE};
                                                                 %%20
B_VALUE_OPTION : TYPE = ValueOption ! B_OPTION;
VALUE_OPTION : TYPE =  {g : B_VALUE_OPTION | g /= ValueOption !
    OPTION_BB};
BOOL_OPTION : TYPE = option {bool} ! OPTION;

Some : [VALUE -> VALUE_OPTION] = ValueOption ! Some;
NUM: [Value!NAT -> VALUE] = Value ! NUM;
STR: [STRING -> VALUE] = Value ! STR;

value_plus : [[VALUE_OPTION, VALUE_OPTION] -> VALUE_OPTION] =    %%30
    Arithmetic ! value_plus;
value_minus : [[VALUE_OPTION, VALUE_OPTION] -> VALUE_OPTION] =
    Arithmetic ! value_minus;

value_eq : [[VALUE_OPTION, VALUE_OPTION] -> BOOL_OPTION] =
    Arithmetic ! value_eq;
value_le : [[VALUE_OPTION, VALUE_OPTION] -> BOOL_OPTION] =
    Arithmetic ! value_le;
value_ge : [[VALUE_OPTION, VALUE_OPTION] -> BOOL_OPTION] =
    Arithmetic ! value_ge;
value_lt : [[VALUE_OPTION, VALUE_OPTION] -> BOOL_OPTION] =
    Arithmetic ! value_lt;                                         %%40
value_gt : [[VALUE_OPTION, VALUE_OPTION] -> BOOL_OPTION] =
    Arithmetic ! value_gt;

OutputSequence : CONTEXT =
    sequence {B_VALUE_OPTION; ValueOption ! OPTION_BB, 1};
InputSequence : CONTEXT =
    sequence {B_VALUE; Value ! VALUE_BB, 1};

gval : [BOOL_OPTION -> bool] =
LAMBDA(g:BOOL_OPTION): g = option {bool} !Some(TRUE);            %%50

drinks : MODULE =
  BEGIN
    INPUT label : LABEL
    LOCAL cfstate : STATES
    LOCAL r_1 : VALUE_OPTION
    INPUT I : InputSequence ! Sequence
    OUTPUT O : OutputSequence ! Sequence                         %%60
    INITIALIZATION [
        cfstate = State_0 AND
        I = InputSequence ! empty AND
        O = OutputSequence ! empty AND
        r_1 = ValueOption ! None
      -->
    ]
    TRANSITION [
      %% init
      INIT :                                                     %%70
          cfstate = State_0 AND label = init AND
              InputSequence ! size?(I) = 0
        -->
          cfstate' = State_1;
          r_1' = Some(NUM(0));
          O' = OutputSequence ! empty
      []
      %% coin
      COIN :
          cfstate = State_1 AND label = coin AND                 %%80
              InputSequence ! size?(I) = 0 AND
              gval(value_le(value_plus(r_1, Some(NUM(1))),
              Some(NUM(N_))))
        -->
          cfstate' = State_1;
          r_1' = value_plus(r_1, Some(NUM(1)));
          O' = OutputSequence ! empty
      []
      %% vend
      VEND :                                                     %%90
          cfstate = State_1 AND label = vend AND
              InputSequence ! size?(I) = 0 AND
              gval(value_gt(r_1, Some(NUM(0)))) AND
              gval(value_le(value_minus(r_1, Some(NUM(1))),
              Some(NUM(N_)))) AND
              gval(value_ge(value_minus(r_1, Some(NUM(1))),
              Some(NUM(0))))
        -->
          cfstate' = State_2;
          r_1' = value_minus(r_1, Some(NUM(1)));                 %%100
          O' = OutputSequence ! empty
      []
      SINK_HOLE :
          ELSE
        -->
          cfstate' = NULL_STATE;
          r_1' = r_1
    ]
  END;
  LTL_label_vend_not_2 : THEOREM drinks |-                       %%110
    label = vend => NOT(F(cfstate = State_2));

  LTL_aux2 : THEOREM drinks |-
    X(label = vend) => NOT(F(cfstate = State_2));

  LTL_init_makes_r_1_zero : THEOREM drinks |-
    label = init AND
        I = InputSequence ! empty =>
        X(gval(value_eq(r_1,(Some(NUM(0))))));
                                                                 %%120
  LTL_must_pay_wrong : THEOREM drinks |-
    U(NOT(U(label = vend, label = coin)), cfstate = NULL_STATE);

  LTL_vend_no_coin : THEOREM drinks |-
    X(label = vend AND
        I = InputSequence ! empty) => NOT(F(cfstate = State_2));

  LTL_invalid_gets_stuck_2 : THEOREM drinks |-
    X(NOT(label = coin AND I = InputSequence ! empty)) AND
        X(NOT(label = vend AND                                     %%130
        I = InputSequence ! empty)) => NOT(F(cfstate = State_2));

  LTL_must_pay_correct : THEOREM drinks |-
    F(cfstate = State_2) => NOT(U(label = vend, label = coin));

  input_can_be_value : THEOREM drinks |-
    I = InputSequence ! singleton(NUM(1)) => X(G(cfstate=NULL_STATE));

END
