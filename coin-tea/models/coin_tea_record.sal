%The biggest absolute integer value used is 1
coin_tea_record {n_ : nznat} : CONTEXT = BEGIN

LABEL : TYPE = DATATYPE
  coin,
  init,
  vend
END;

STRING : TYPE = {String__tea, String__dummy__};                  %%10

STATE : TYPE = {State__0, State__1, State__2, NULL_STATE};

IMPORTING trilean;
IMPORTING value{n_, STRING};
IMPORTING option{VALUE};
IMPORTING arithmetic{n_, STRING};

max_input: nznat = 1;

length(inputs : [# i0: B_VALUE , i1: B_VALUE #], len : nznat) : BOOLEAN =
  IF len = 0 THEN
    inputs = (#i0 := ValueBB, i1 := ValueBB#)
  ELSIF len = 1 THEN
    EXISTS(v1 : VALUE): inputs = (#i0 := v1, i1 := ValueBB#)
  ELSIF len = 2 THEN
    EXISTS(v1, v2: VALUE): inputs = (#i0 := v1, i1 := v2#)
  ELSE
    FALSE
  ENDIF;

drinks : MODULE =
  BEGIN
    INPUT label : LABEL
    LOCAL cfstate : STATE
    LOCAL r__1 : OPTION
    INPUT i : [# i0: B_VALUE , i1: B_VALUE #]
    OUTPUT o : [# o0: B_OPTION , o1: B_OPTION #]
    INITIALIZATION [
        cfstate = State__0 AND                                   %%30
        o = (# o0:=OptionBB, o1:=OptionBB #) AND
        r__1 = None
      -->
    ]
    TRANSITION [
      INIT :
          cfstate = State__0 AND label = init AND
              length(i, 0)
        -->
          cfstate' = State__1;                                   %%40
          r__1' = Some(Num(0));
          o' = (# o0:=OptionBB, o1:=OptionBB #)
      []
      COIN :
          cfstate = State__1 AND label = coin AND
              length(i, 0) AND
              check_overflow(value_plus(r__1, Some(Num(1)))) AND
              check_underflow(value_plus(r__1, Some(Num(1))))
        -->
          cfstate' = State__1;                                   %%50
          r__1' = value_plus(r__1, Some(Num(1)));
          o' = (# o0:=OptionBB, o1:=OptionBB #)
      []
      VEND :
          cfstate = State__1 AND label = vend AND
              length(i, 0) AND
              gval(value_ge(r__1, Some(Num(0))))
        -->
          cfstate' = State__2;
          o' = (# o0:=Some(Str(String__tea)), o1:=OptionBB #)
      []
      SINK_HOLE :
          ELSE
        -->
          cfstate' = NULL_STATE;
          o' = (# o0:=OptionBB, o1:=OptionBB #)
    ]
  END;                                                           %%70
  LTL_label_vend_not_2 : THEOREM drinks |-
    label = vend => NOT (F(cfstate = State__2));

  LTL_aux2 : THEOREM drinks |-
    X(label = vend) => NOT (F(cfstate = State__2));

  LTL_must_pay_wrong : THEOREM drinks |-
    U(NOT (U(label = vend, label = coin)), cfstate = NULL_STATE);

  LTL_vend_no_coin : THEOREM drinks |-                           %%80
    X(label = vend AND
        i = (# i0:=ValueBB, i1:=ValueBB #)) => NOT (F(cfstate = State__2));

  LTL_invalid_gets_stuck_2 : THEOREM drinks |-
    X(NOT (label = coin AND i = (# i0:=ValueBB, i1:=ValueBB #))) AND
        X(NOT (label = vend AND
        i = (# i0:=ValueBB, i1:=ValueBB #))) =>
        NOT (F(cfstate = State__2));

  LTL_must_pay_correct : THEOREM drinks |-                       %%90
    F(cfstate = State__2) => U(NOT (label = vend), label = coin);

  LTL_must_pay_correct_bracketed : THEOREM drinks |-
    F(cfstate = State__2) => U(NOT (label = vend), label = coin);

END
