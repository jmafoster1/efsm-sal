package isabelle2sal;

import java.io.*;
import java.nio.file.Path;

/**
 * Deals with the output of the dot version from the sal version which originally
 * came from the isabelle version
 * @author sdn
 */
public class Dot {
    
    // Dot Utilities
   
    private enum DotStatementType{GRAPH, NODE, EDGE};
    
    final String TAB ="    ";
    final String OPEN_SQUARE = "&#91;";
    final String CLOSE_SQUARE = "&#93;";   
            
    private class IDPair {
        String left, right;
        
        private void output() {
            write(left);
            write("=");
            write(right);
        }
        
        private IDPair (String l, String r) {
            left = l;
            right = r;
        }
        
    }
                                     
    private String guardsOf(Transition t) {
        
        String guards = "";        
        
        if  (  t.getGuard() == null )  
            return guards;
        
        for (Guard p : t.getGuard())  {            
            guards +=p.toDot();
            guards+=", ";                    
        }
        
        return 
            OPEN_SQUARE + 
            guards.substring(0, guards.length()-2) +//get rid of trailing comma
            CLOSE_SQUARE;
                
    }
    
    private String outputsOf(Transition t) {
        String outputs = "";
        for (Assignment u : t.getUpdates())
            outputs = outputs + u.outputOutputsAsDot();                    
        if  (  outputs.length() == 0  )  
            return outputs;
        else 
            return 
                outputs.substring(0, outputs.length()-2);//get rid of trailing comma
    }
    
    private String updatesOf(Transition t) {
        //The updates of t in square brackets   
        
        String updates = "";
        for (Assignment u : t.getUpdates()) 
            updates = updates + u.outputRegistersAsDot();                
        if  (  updates.length() == 0  )  return updates;        
        return 
                OPEN_SQUARE+
                updates.substring(0, updates.length()-2) + //get rid of trailing comma
                CLOSE_SQUARE;
    }
    
    //Outputting elements of the dot syntax
    
    private void outputAList(IDPair ... pairs) {
        // a_list	:	ID '=' ID [ (';' | ',') ] [ a_list ]
        for (IDPair i : pairs)  {
            i.output();
            if  (  i != pairs[pairs.length-1]  )  write(", ");
        }
    }
    
    private void outputAttributeList(IDPair ... aList) {
        //attr_list	:	'[' [ a_list ] ']' [ attr_list ]
        if   (  aList.length == 0 )  
            write("[]");
        else {
            write("[");
            outputAList(aList);
            write("]");
        }         
    }
    
    private void outputAttributeStatement(DotStatementType t, IDPair ... attributeList) {
        //attr_stmt	:	(graph | node | edge) attr_list 
        write(TAB+t.toString().toLowerCase()+" ");
        outputAttributeList(attributeList);
        writeLine(";");
    }
    
    private void outputEdgeStatement(Transition t, String suffix) {
        //edge_stmt	:	(node_id | subgraph) edgeRHS [ attr_list ]

        SystemConstant left = t.initialState();
        SystemConstant right = 
                ((ConstantExpression)(t.getUpdates()).get(0).getValue()).getState(); 

        //(node_id | subgraph)            
            write(TAB+left.toDot()+suffix);
                
        //edgeRHS	:	edgeop (node_id | subgraph) [ edgeRHS ]
            //edgeop 
                write("->");
            //(node_id | subgraph)
                write(right.toDot()+suffix);                 
           // [ edgeRHS ]    
            
        //[ attr_list ]
        outputAttributeList(
                new IDPair("label", 
                        "<<i>" +   
                        t.getLabelAsString() + ":" + String.valueOf(t.getArity())+
                        guardsOf(t)+
                        "/" +
                        outputsOf(t)+
                        updatesOf(t)+
                        "</i>>"));
       
        writeLine(";");
                        
    }
    
    private void outputGraphFrom(SAL sal)   {
        // graph	: [ strict ] (graph | digraph) [ ID ] '{' stmt_list '}'
        writeLine("/* Generated by the Isabelle to SAL translator */");
        writeLine("/* " + Translator.VERSION+" */");
        writeLine("digraph " + name + "{");
        outputStatementListFrom(sal);
        writeLine("}");
    }
    
    private void outputNodeStatement(Integer s, String suffix, boolean first) {
        // node_stmt	:	node_id [ attr_list ]   
                
        write(TAB + "s"+s+suffix);
        IDPair labelEqualsState = new IDPair("label", "<s<sub>"+s+"</sub>>");
        if  (  first  )  
             outputAttributeList(
                     new IDPair("fillcolor", "\"gray\""),
                     labelEqualsState);
        else
             outputAttributeList(labelEqualsState);
        writeLine(";");
    }
    
    private void outputEFSM(SAL sal, Integer eNo)  {
        EFSM e = (   eNo==null ? EFSM.theEFSMs()[0] : EFSM.theEFSMs()[eNo]);
        
        writeLine();
        
        if  (  eNo != null  )  {
            writeLine("  subgraph cluster_" + (eNo+1) + " {");
            writeLine(TAB+"label = \""+e.getIdentifier()+"\";");
            writeLine();
        }
        
        boolean first = true;
        String suffix = (  eNo==null ? "" : String.valueOf((char)('a'+eNo)));
        for (Integer s : EFSM.allStates()) 
            if  (  e.hasState(s) )   {
                outputNodeStatement(s, suffix, first);
                first = false;
            }
        
        
        writeLine();
        
        for (Transition t : e.dotTransitions())
            outputEdgeStatement(t,suffix);
        
        if  (  eNo != null  )  
            writeLine("  }");

    }
    
    private void outputStatementListFrom(SAL sal)  {
        final IDPair FONT = new IDPair("fontname", "\"Latin Modern Math\"");
        //stmt_list	:	[ stmt [ ';' ] stmt_list ]
        
        outputAttributeStatement(DotStatementType.GRAPH,
                new IDPair("rankdir", "\"LR\""), FONT);
        outputAttributeStatement(DotStatementType.NODE,
                new IDPair("color", "\"black\""), 
                new IDPair("fillcolor", "\"white\""), 
                new IDPair("shape", "\"circle\""), 
                new IDPair("style", "\"filled\"" ), FONT);
        outputAttributeStatement(DotStatementType.EDGE, FONT);
        
        if (  EFSM.theEFSMs().length == 1  )
            outputEFSM(sal, null);
        else
            for (int i=0; i<EFSM.theEFSMs().length; i++)
                outputEFSM(sal, i);
        
    }
    
    //Instance variables
    
    private String name;
        
    //File utilities
    
    private PrintWriter destination;
    
    private void closeTheFile()  {
        destination.close();
    }
    
    private void write(String l)  {
        destination.print(l);
    }
    
    private void writeLine(String l)  {
        destination.print(l);
        destination.println();
    }
    
    private void writeLine()  {
        destination.println();
    }
    
    //Public methods
    
    public Dot(Path directory, String file) throws  FileException {
        try {
            destination = new PrintWriter(
                    new FileWriter(directory.resolve(file+".dot").toFile()));   
            name = file;
        } catch  (IOException e) {
           throw new FileException("System failed to create ouptut Dot file because "+e.toString());
        }                     
    }
    
    public void outputFrom(SAL sal)  {       
        outputGraphFrom(sal);       
        closeTheFile();       
    }
    
}
