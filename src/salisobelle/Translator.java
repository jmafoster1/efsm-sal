package salisobelle;

import static salisobelle.Generator.*;
import static salisobelle.Parser.*;

import java.nio.file.*;

/**
 * The bit that does all the work
 * @author Siobhan
 */

public class Translator {
    
    final static String VERSION = "Version 1.9 released 6 December 2021";
    final static String SYSTEM_MARKER = "__";
      
    //::::::::::::::::::::::::::: Input as SAL
    
    private void skipToAfter(Token t) throws TranslationException {
        while (  ! nextTokenIs(t) )  acceptToken();     
        accept(t);
    }      
    
    private String acceptNewNameWithColon() throws TranslationException {
        nextTokenMustBe(Token.NEW_WORD);
        String id = acceptedWord();
        accept(Token.COLON);  
        return id;
    }
    
    void readInFrom(Path source) throws TranslationException  { 
        Parser parser = new Parser(source);
                           
        SystemConstant.readInDeclarations();

        //Skip to end of context
        skipToAfter(Token.OUTPUT_SEQUENCE);        
        skipToAfter(Token.SEMICOLON);
        
        //Deal with modules if any
        String name = acceptNewNameWithColon();
        nextTokenMustBeOneOf(Token.MODULE, Token.THEOREM);
        
        while  (  nextTokenIs(Token.MODULE)  )  {
            
            EFSM.createOneCalled(name);
            
            skipToAfter(Token.TRANSITION);
            accept(Token.OPENING_SQUARE_BRACKET);
            
            do 
                Transition.inputDefinitionAsSAL(EFSM.theOnlyOne());
            while ( ! acceptedTokenWas(Token.SINK_HOLE));
            
            skipToAfter(Token.CLOSING_SQUARE_BRACKET);
            accept(Token.END, Token.SEMICOLON);
            
            nextTokenMustBeOneOf(Token.END, Token.NEW_WORD);            
            if  (  nextTokenIs(Token.NEW_WORD)  )  {
                name = acceptNewNameWithColon();
                nextTokenMustBeOneOf(Token.MODULE, Token.THEOREM);
            }
            
        }
        
        //Deal with theorems if any
        assert nextTokenIsOneOf(Token.END, Token.THEOREM);
        while (  nextTokenIs(Token.THEOREM)  )  {
            Lemma.acceptOneCalled(name);
            nextTokenMustBeOneOf(Token.NEW_WORD, Token.END);
            if  (  nextTokenIs(Token.NEW_WORD)  )  
                name = acceptNewNameWithColon();
            nextTokenMustBeOneOf (Token.END, Token.THEOREM);
        }
        
        accept(Token.END);
                       
        parser.close();
    }  
       
    //::::::::::::::::::::::::::: Output as Isabelle
    
    private String isabelleNameOf(String salName)  {
        //starts with upper case letter
        salName = Character.toUpperCase(salName.charAt(0))+salName.substring(1);
        int underscore = salName.indexOf("_");
        while  (  underscore > 0 )  {
            if  (  Character.isLetter(salName.charAt(underscore+1)))  
                salName = salName.substring(0,underscore+1) + 
                        Character.toUpperCase(salName.charAt(underscore+1))+
                        salName.substring(underscore+2);
            underscore =salName.indexOf('_',underscore+1);
        }
        return salName.replace(".thy","");       
    }
        
    void exportAsIsbelle(Path outputFile) throws TranslationException { 
        
        startIsabelleOutput(outputFile);

        outputIsabelleLine("(* Generated by the SAL to Isabelle Translator *)");
        outputIsabelleLine("(* " + Translator.VERSION +" *)");
        
        outputBlankLineInIsabelle();
        
        outputIsabelleLine("theory "+isabelleNameOf(outputFile.getFileName().toString()));
        outputIsabelleLine("  imports \"Extended_Finite_State_Machines.EFSM_LTL\"");
        outputIsabelleLine("begin");
        
        outputBlankLineInIsabelle();
        
        outputIsabelleLine("declare One_nat_def [simp del]");
        outputIsabelleLine("declare ltl_step_alt [simp]");
        
        outputBlankLineInIsabelle();
        
        for (Transition t : Transition.allOfThem())
            t.outputInIsabelle();
        
        outputBlankLineInIsabelle();
        
        EFSM.theOnlyOne.outputAsIsabelle();
        
        outputBlankLineInIsabelle();

        outputIsabelleLine("lemmas transitions = ");
        increaseMarginOnOutput();
            for (Transition t : Transition.allOfThem())  
                outputIsabelleLine(t.getIdentifier().toLowerCase()+"_def");
        decreaseMarginOnOutput();

        outputBlankLineInIsabelle();

        for (Lemma l : Lemma.theTheorems())
            l.outputInIsabelle();
        
        outputBlankLineInIsabelle();
        
        outputIsabelleLine("end");
        
        finishIsabelleOutputSuccessfully(true);

    }
    
    //::::::::::::::::::::::::::: The workings

    private static void clearEverything() {
        EFSM.clearAll();
        Lemma.clearAll();
        Parser.clearAll();
        Constant.clearAll();
        Transition.clearAll();
    }
    
    void readSALWriteIsabelle(Path source) throws TranslationException { 
        final String GENERATED_MARKER = "XXSALXX";
        String fileName = source.getFileName().toString().replace(".sal",".thy");
        Path destination = source.getParent().resolve(fileName);
        
        while  (  Files.exists(destination)  ) {
            fileName = GENERATED_MARKER+fileName;
            destination = source.getParent().resolve(fileName);
        }
        
        clearEverything();
        
        readInFrom(source);        
        exportAsIsbelle(destination);
    }     
                      
}
