(* Generated by the Dot to Isabelle Translator *)
(* Version 1.5 released 25 June 2021 *)
theory XXDOTXXLift_Controller_LTL
imports "EFSM.EFSM"
begin

definition "continit" :: "transition" where
"continit \<equiv> \<lparr>
      Label = STR ''continit'',
      Arity = 0,
      Guards = [],
      Outputs = [],
      Updates = [
            (1, (L (Str ''true'')))
      ]
\<rparr>"

definition "motorstop" :: "transition" where
"motorstop \<equiv> \<lparr>
      Label = STR ''motorstop'',
      Arity = 2,
      Guards = [
            (gexp.Eq (V (R 1)) (L (Str ''true''))),
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''true'')))
      ],
      Outputs = [
            (L (Num 0)),
            (L (Num 4)),
            (L (Str ''true''))
      ],
      Updates = []
\<rparr>"

definition "motorstop1" :: "transition" where
"motorstop1 \<equiv> \<lparr>
      Label = STR ''motorstop'',
      Arity = 2,
      Guards = [
            (gexp.Eq (V (R 1)) (L (Str ''true''))),
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''true'')))
      ],
      Outputs = [
            (L (Num 0)),
            (L (Num 3)),
            (L (Str ''true''))
      ],
      Updates = []
\<rparr>"

definition "motorstop2" :: "transition" where
"motorstop2 \<equiv> \<lparr>
      Label = STR ''motorstop'',
      Arity = 2,
      Guards = [
            (gexp.Eq (V (R 1)) (L (Str ''true''))),
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''true'')))
      ],
      Outputs = [
            (L (Num 0)),
            (L (Num 2)),
            (L (Str ''true''))
      ],
      Updates = []
\<rparr>"

definition "motorstop3" :: "transition" where
"motorstop3 \<equiv> \<lparr>
      Label = STR ''motorstop'',
      Arity = 2,
      Guards = [
            (gexp.Eq (V (R 1)) (L (Str ''true''))),
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''true'')))
      ],
      Outputs = [
            (L (Num 0)),
            (L (Num 1)),
            (L (Str ''true''))
      ],
      Updates = []
\<rparr>"

definition "startsearch" :: "transition" where
"startsearch \<equiv> \<lparr>
      Label = STR ''startsearch'',
      Arity = 2,
      Guards = [
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''false'')))
      ],
      Outputs = [],
      Updates = []
\<rparr>"

definition "startsearch1" :: "transition" where
"startsearch1 \<equiv> \<lparr>
      Label = STR ''startsearch'',
      Arity = 2,
      Guards = [
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''false'')))
      ],
      Outputs = [],
      Updates = []
\<rparr>"

definition "startsearch2" :: "transition" where
"startsearch2 \<equiv> \<lparr>
      Label = STR ''startsearch'',
      Arity = 2,
      Guards = [
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''false'')))
      ],
      Outputs = [],
      Updates = []
\<rparr>"

definition "startsearch3" :: "transition" where
"startsearch3 \<equiv> \<lparr>
      Label = STR ''startsearch'',
      Arity = 2,
      Guards = [
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''false'')))
      ],
      Outputs = [],
      Updates = []
\<rparr>"

definition "opendoor" :: "transition" where
"opendoor \<equiv> \<lparr>
      Label = STR ''opendoor'',
      Arity = 1,
      Guards = [
            (gexp.Eq (V (I 0)) (L (Str ''true'')))
      ],
      Outputs = [
            (L (Str ''true'')),
            (L (Num 4))
      ],
      Updates = []
\<rparr>"

definition "opendoor1" :: "transition" where
"opendoor1 \<equiv> \<lparr>
      Label = STR ''opendoor'',
      Arity = 1,
      Guards = [
            (gexp.Eq (V (I 0)) (L (Str ''true'')))
      ],
      Outputs = [
            (L (Str ''true'')),
            (L (Num 3))
      ],
      Updates = []
\<rparr>"

definition "opendoor2" :: "transition" where
"opendoor2 \<equiv> \<lparr>
      Label = STR ''opendoor'',
      Arity = 1,
      Guards = [
            (gexp.Eq (V (I 0)) (L (Str ''true'')))
      ],
      Outputs = [
            (L (Str ''true'')),
            (L (Num 2))
      ],
      Updates = []
\<rparr>"

definition "opendoor3" :: "transition" where
"opendoor3 \<equiv> \<lparr>
      Label = STR ''opendoor'',
      Arity = 1,
      Guards = [
            (gexp.Eq (V (I 0)) (L (Str ''true'')))
      ],
      Outputs = [
            (L (Str ''true'')),
            (L (Num 1))
      ],
      Updates = []
\<rparr>"

definition "return" :: "transition" where
"return \<equiv> \<lparr>
      Label = STR ''return'',
      Arity = 0,
      Guards = [
            (gexp.Eq (V (R 4)) (L (Num 4)))
      ],
      Outputs = [],
      Updates = []
\<rparr>"

definition "return1" :: "transition" where
"return1 \<equiv> \<lparr>
      Label = STR ''return'',
      Arity = 0,
      Guards = [
            (gexp.Eq (V (R 4)) (L (Num 3)))
      ],
      Outputs = [],
      Updates = []
\<rparr>"

definition "return2" :: "transition" where
"return2 \<equiv> \<lparr>
      Label = STR ''return'',
      Arity = 0,
      Guards = [
            (gexp.Eq (V (R 4)) (L (Num 2)))
      ],
      Outputs = [],
      Updates = []
\<rparr>"

definition "return3" :: "transition" where
"return3 \<equiv> \<lparr>
      Label = STR ''return'',
      Arity = 0,
      Guards = [
            (gexp.Eq (V (R 4)) (L (Num 1)))
      ],
      Outputs = [],
      Updates = []
\<rparr>"

definition "down" :: "transition" where
"down \<equiv> \<lparr>
      Label = STR ''down'',
      Arity = 3,
      Guards = [
            (gexp.Eq (V (R 2)) (L (Num 2))),
            (gexp.Eq (V (R 1)) (L (Str ''false''))),
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''true''))),
            (gexp.Eq (V (I 2)) (L (Str ''true'')))
      ],
      Outputs = [
            (L (Num 2)),
            (L (Str ''true''))
      ],
      Updates = [
            (4, (L (Num 3))),
            (1, (L (Str ''true'')))
      ]
\<rparr>"

definition "down1" :: "transition" where
"down1 \<equiv> \<lparr>
      Label = STR ''down'',
      Arity = 3,
      Guards = [
            (gexp.Eq (V (R 2)) (L (Num 2))),
            (gexp.Eq (V (R 1)) (L (Str ''false''))),
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''true''))),
            (gexp.Eq (V (I 2)) (L (Str ''false'')))
      ],
      Outputs = [
            (L (Num 2)),
            (L (Str ''false''))
      ],
      Updates = [
            (4, (L (Num 3))),
            (1, (L (Str ''false'')))
      ]
\<rparr>"

definition "up" :: "transition" where
"up \<equiv> \<lparr>
      Label = STR ''up'',
      Arity = 2,
      Guards = [
            (gexp.Eq (V (R 2)) (L (Num 1))),
            (gexp.Eq (V (R 1)) (L (Str ''false''))),
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''true'')))
      ],
      Outputs = [
            (L (Num 1)),
            (L (Str ''true''))
      ],
      Updates = [
            (4, (L (Num 4))),
            (1, (L (Str ''true'')))
      ]
\<rparr>"

definition "down2" :: "transition" where
"down2 \<equiv> \<lparr>
      Label = STR ''down'',
      Arity = 3,
      Guards = [
            (gexp.Eq (V (R 2)) (L (Num 2))),
            (gexp.Eq (V (R 1)) (L (Str ''false''))),
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''true''))),
            (gexp.Eq (V (I 2)) (L (Str ''true'')))
      ],
      Outputs = [
            (L (Num 2)),
            (L (Str ''true''))
      ],
      Updates = [
            (4, (L (Num 2))),
            (1, (L (Str ''true'')))
      ]
\<rparr>"

definition "down3" :: "transition" where
"down3 \<equiv> \<lparr>
      Label = STR ''down'',
      Arity = 3,
      Guards = [
            (gexp.Eq (V (R 2)) (L (Num 2))),
            (gexp.Eq (V (R 1)) (L (Str ''false''))),
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''true''))),
            (gexp.Eq (V (I 2)) (L (Str ''false'')))
      ],
      Outputs = [
            (L (Num 2)),
            (L (Str ''false''))
      ],
      Updates = [
            (4, (L (Num 2))),
            (1, (L (Str ''false'')))
      ]
\<rparr>"

definition "up1" :: "transition" where
"up1 \<equiv> \<lparr>
      Label = STR ''up'',
      Arity = 3,
      Guards = [
            (gexp.Eq (V (R 2)) (L (Num 1))),
            (gexp.Eq (V (R 1)) (L (Str ''false''))),
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''true''))),
            (gexp.Eq (V (I 2)) (L (Str ''true'')))
      ],
      Outputs = [
            (L (Num 1)),
            (L (Str ''true''))
      ],
      Updates = [
            (4, (L (Num 3))),
            (1, (L (Str ''true'')))
      ]
\<rparr>"

definition "up2" :: "transition" where
"up2 \<equiv> \<lparr>
      Label = STR ''up'',
      Arity = 3,
      Guards = [
            (gexp.Eq (V (R 2)) (L (Num 1))),
            (gexp.Eq (V (R 1)) (L (Str ''false''))),
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''true''))),
            (gexp.Eq (V (I 2)) (L (Str ''false'')))
      ],
      Outputs = [
            (L (Num 1)),
            (L (Str ''false''))
      ],
      Updates = [
            (4, (L (Num 3))),
            (1, (L (Str ''false'')))
      ]
\<rparr>"

definition "down4" :: "transition" where
"down4 \<equiv> \<lparr>
      Label = STR ''down'',
      Arity = 2,
      Guards = [
            (gexp.Eq (V (R 2)) (L (Num 2))),
            (gexp.Eq (V (R 1)) (L (Str ''false''))),
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''true'')))
      ],
      Outputs = [
            (L (Num 2)),
            (L (Str ''true''))
      ],
      Updates = [
            (3, (L (Num 1))),
            (1, (L (Str ''true'')))
      ]
\<rparr>"

definition "up3" :: "transition" where
"up3 \<equiv> \<lparr>
      Label = STR ''up'',
      Arity = 3,
      Guards = [
            (gexp.Eq (V (R 2)) (L (Num 1))),
            (gexp.Eq (V (R 1)) (L (Str ''false''))),
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''true''))),
            (gexp.Eq (V (I 2)) (L (Str ''true'')))
      ],
      Outputs = [
            (L (Num 1)),
            (L (Str ''true''))
      ],
      Updates = [
            (1, (L (Str ''true''))),
            (4, (L (Num 2)))
      ]
\<rparr>"

definition "up4" :: "transition" where
"up4 \<equiv> \<lparr>
      Label = STR ''up'',
      Arity = 3,
      Guards = [
            (gexp.Eq (V (R 2)) (L (Num 1))),
            (gexp.Eq (V (R 1)) (L (Str ''false''))),
            (gexp.Eq (V (I 0)) (L (Str ''true''))),
            (gexp.Eq (V (I 1)) (L (Str ''true''))),
            (gexp.Eq (V (I 2)) (L (Str ''false'')))
      ],
      Outputs = [
            (L (Num 1)),
            (L (Str ''false''))
      ],
      Updates = [
            (4, (L (Num 2))),
            (1, (L (Str ''false'')))
      ]
\<rparr>"

definition "lift_controller_ltl" :: "transition_matrix" where
"lift_controller_ltl \<equiv> {|
      ((0, 9), continit),
      ((4, 8), motorstop),
      ((3, 7), motorstop1),
      ((2, 6), motorstop2),
      ((1, 5), motorstop3),
      ((8, 9), startsearch),
      ((7, 9), startsearch1),
      ((6, 9), startsearch2),
      ((5, 9), startsearch3),
      ((8, 8), opendoor),
      ((7, 7), opendoor1),
      ((6, 6), opendoor2),
      ((5, 5), opendoor3),
      ((9, 4), return),
      ((9, 3), return1),
      ((9, 2), return2),
      ((9, 1), return3),
      ((4, 3), down),
      ((4, 3), down1),
      ((3, 4), up),
      ((3, 2), down2),
      ((3, 2), down3),
      ((2, 3), up1),
      ((2, 3), up2),
      ((2, 1), down4),
      ((1, 2), up3),
      ((1, 2), up4)
|}"

lemmas transitions =
      continit_def
      motorstop_def
      motorstop1_def
      motorstop2_def
      motorstop3_def
      startsearch_def
      startsearch1_def
      startsearch2_def
      startsearch3_def
      opendoor_def
      opendoor1_def
      opendoor2_def
      opendoor3_def
      return_def
      return1_def
      return2_def
      return3_def
      down_def
      down1_def
      up_def
      down2_def
      down3_def
      up1_def
      up2_def
      down4_def
      up3_def
      up4_def

end
