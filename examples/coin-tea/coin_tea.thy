(* Generated by the SAL to Isabelle Translator *)
(* Version 1.5 released 25 June 2021 *)

theory coin_tea
imports "EFSM.EFSM_LTL" Coin_Tea
begin

declare One_nat_def [simp del]
declare ltl_step_alt [simp]

definition init :: "transition" where
"init \<equiv> \<lparr>
    Label = (STR ''init''),
    Arity = 0,
    Guards = [],
    Outputs = [],
    Updates = [
      (1, (L (Num 0)))
    ]
\<rparr>"

definition coin :: "transition" where
"coin \<equiv> \<lparr>
    Label = (STR ''coin''),
    Arity = 0,
    Guards = [],
    Outputs = [],
    Updates = [
      (1, (Plus (V (R 1)) (L (Num 1))))
    ]
\<rparr>"

definition vend :: "transition" where
"vend \<equiv> \<lparr>
    Label = (STR ''vend''),
    Arity = 0,
    Guards = [
      (Gt (V (R 1)) (L (Num 0)))
    ],
    Outputs = [
      (L (Str ''tea''))
    ],
    Updates = []
\<rparr>"


definition drinks :: "transition_matrix" where
"drinks \<equiv> {|
    ((0, 1), init),
    ((1, 1), coin),
    ((1, 2), vend)
  |}"
  
  
lemmas transitions =
  init_def
  coin_def
  vend_def

lemma drinks_equiv [simp]: "drinks = Coin_Tea.drinks"
  by (simp add: drinks_def Coin_Tea.drinks_def transitions Coin_Tea.transitions)
  
lemma LTL_label_vend_not_2 :
  "(label_eq ''vend'' impl not (ev (state_eq (Some 2))))
(watch drinks trace)"
  using LTL_label_vend_not_2 by simp

lemma LTL_aux2 :
  "(nxt (label_eq ''vend'') impl not (ev (state_eq (Some 2))))
(watch drinks trace)"
  using LTL_aux2 by simp

lemma LTL_init_makes_r_1_zero :
  "((label_eq ''init'' aand
      input_eq []) impl
      nxt (check_exp ((Eq (V (Rg 1)) (L (Num 0))))))
(watch drinks trace)"
  using LTL_init_makes_r_1_zero by simp

lemma LTL_must_pay_wrong :
  "(not (label_eq ''vend'' suntil label_eq ''coin'') suntil
      state_eq None)
(watch drinks trace)"
  oops (* Not true *)

lemma LTL_vend_no_coin :
  "(nxt (label_eq ''vend'' aand
      input_eq []) impl not (ev (state_eq (Some 2))))
(watch drinks trace)"
  using LTL_vend_no_coin by simp

lemma LTL_invalid_gets_stuck_2 :
  "((nxt (not (label_eq ''coin'' aand input_eq [])) aand
      nxt (not (label_eq ''vend'' aand
      input_eq []))) impl not (ev (state_eq (Some 2))))
(watch drinks trace)"
  using LTL_invalid_gets_stuck_2 by simp

lemma LTL_must_pay_correct :
  "(ev (state_eq (Some 2)) impl
      (not (label_eq ''vend'') suntil label_eq ''coin''))
(watch drinks trace)"
  using LTL_must_pay_correct by simp

lemma LTL_must_pay_correct_bracketed :
  "(ev (state_eq (Some 2)) impl
      (not (label_eq ''vend'') suntil label_eq ''coin''))
(watch drinks trace)"
  using LTL_must_pay_correct_bracketed by simp

end
