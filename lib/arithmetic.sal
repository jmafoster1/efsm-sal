arithmetic {N_ : nznat; STRING:TYPE} : CONTEXT = BEGIN
  b_value : TYPE =  value {N_, STRING} ! B_VALUE;
  a_value : TYPE =  {g : b_value | g /= value {N_, STRING} ! VALUE_BB};
  b_value_option : TYPE =  option {a_value} ! B_OPTION;
  a_value_option : TYPE =  {g : b_value_option | g /= option {a_value} ! OPTION_BB};

  valueOf : [b_value_option -> a_value] = option {a_value} ! valueOf;
  None : a_value_option = option {a_value} ! None;
  None? : [b_value_option -> bool] = option {a_value} ! None?;
  Some? : [b_value_option -> bool] = option {a_value} ! Some?;

  STR?: [b_value -> bool] = value {N_, STRING} ! STR?;
  NUM?: [b_value -> bool] = value {N_, STRING} ! NUM?;
  natOf: [b_value -> nznat] = value {N_, STRING} ! natOf;
  NUM: [value{N_, STRING}!NAT -> a_value] = value {N_, STRING} ! NUM;

  bool_option:TYPE = option {bool} ! OPTION;

  SomeNUM?: [a_value_option -> bool] =
  LAMBDA(a:a_value_option): IF Some?(a) THEN NUM?(valueOf(a)) ELSE FALSE ENDIF;

  maybe_bool_int : [[[[nznat, nznat] -> bool], a_value_option, a_value_option] -> bool_option] =
  LAMBDA(f:[[nznat, nznat] -> bool], x1 : a_value_option, x2: a_value_option):
    IF Some?(x1) AND Some?(x2) THEN
      IF NUM?(valueOf(x1)) AND NUM?(valueOf(x2))
      THEN
        option {bool} !Some(f(natOf(valueOf(x1)), natOf(valueOf(x2))))
      ELSE
        option {bool} ! None
      ENDIF
    ELSE
      option {bool} ! None
    ENDIF;

  value_gt : [[a_value_option, a_value_option] -> bool_option] =
  LAMBDA(x:a_value_option, y:a_value_option): maybe_bool_int(LAMBDA(x:nznat, y:nznat): x > y, x, y);

  value_lt : [[a_value_option, a_value_option] -> bool_option] =
  LAMBDA(x:a_value_option, y:a_value_option): maybe_bool_int(LAMBDA(x:nznat, y:nznat): x < y, x, y);

  value_ge : [[a_value_option, a_value_option] -> bool_option] =
  LAMBDA(x:a_value_option, y:a_value_option): maybe_bool_int(LAMBDA(x:nznat, y:nznat): x >= y, x, y);

  value_le : [[a_value_option, a_value_option] -> bool_option] =
  LAMBDA(x:a_value_option, y:a_value_option): maybe_bool_int(LAMBDA(x:nznat, y:nznat): x <= y, x, y);

  value_eq : [[a_value_option, a_value_option] -> bool_option] =
  LAMBDA(x:a_value_option, y:a_value_option): option {bool} ! Some(x=y);

  maybe_bool_op : [[[[bool, bool] -> bool], bool_option, bool_option] -> bool_option] =
  LAMBDA(f:[[bool, bool] -> bool], x1 : bool_option, x2: bool_option):
    IF option {bool} !Some?(x1) AND option {bool} !Some?(x2) THEN
      option {bool} !Some(f(option {bool} !valueOf(x1), option {bool} !valueOf(x2)))
    ELSE
      option {bool} !None
    ENDIF;

  maybe_and : [[bool_option, bool_option] -> bool_option] =
  LAMBDA(x1:bool_option, x2:bool_option):maybe_bool_op(LAMBDA(x:bool, y:bool):x AND y, x1, x2);

  maybe_or : [[bool_option, bool_option] -> bool_option] =
  LAMBDA(x1:bool_option, x2:bool_option):maybe_bool_op(LAMBDA(x:bool, y:bool):x OR y, x1, x2);

  maybe_not: [[bool_option, bool_option] -> bool_option] =
  LAMBDA(x1 : bool_option, x2: bool_option):
    IF option {bool} !Some?(x1) THEN
      option {bool} !Some(NOT(option {bool} !valueOf(x1)))
    ELSE
      option {bool} !None
    ENDIF;

    maybe_nor : [[bool_option, bool_option] -> bool_option] =
    LAMBDA(x1:bool_option, x2:bool_option):maybe_bool_op(LAMBDA(x:bool, y:bool):NOT(x OR y), x1, x2);

  maybe_arith_int : [[[[nznat, nznat] -> nznat], a_value_option, a_value_option] -> a_value_option] =
  LAMBDA(f:[[nznat, nznat] -> nznat], x1 : a_value_option, x2: a_value_option):
    IF Some?(x1) AND Some?(x2) THEN
      IF NUM?(valueOf(x1)) AND NUM?(valueOf(x2))
      THEN
        option {a_value} !Some(NUM(f(natOf(valueOf(x1)), natOf(valueOf(x2)))))
      ELSE
        None
      ENDIF
    ELSE
      None
    ENDIF;

  value_plus : [[a_value_option, a_value_option] -> a_value_option] =
  LAMBDA(x:a_value_option, y:a_value_option): maybe_arith_int(LAMBDA(x:nznat, y:nznat): x + y, x, y);

  value_minus : [[a_value_option, a_value_option] -> a_value_option] =
  LAMBDA(x:a_value_option, y:a_value_option): maybe_arith_int(LAMBDA(x:nznat, y:nznat): x - y, x, y);

END
